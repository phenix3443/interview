# -*- coding:utf-8-*-
#+TITLE: 线程面试问题
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 什么是线程？它出现的背景是什么？
  引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

  线程最直接的理解就是 “轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。

* 线程的基本状态及状态之间的关系？
  线程是程序执行流的最小单元。线程的基本状态包括：新线程态、可运行态、阻塞/非运行态、死亡态。

  各状态之间的关系如下：

  #+CAPTION: 线程状态
  #+NAME:   fig:SED-HR4049
  [[http://static.oschina.net/uploads/space/2013/1230/163922_UEm6_1426828.jpg]]

* 线程的实现方式[fn:1]
  线程的实现可以分为两类：用户级线程 (User-LevelThread, ULT) 和内核级线程 (Kemel-LevelThread, KLT)。内核级线程又称为内核支持的线程。

 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图 2-2(a) 说明了用户级线程的实现方式。

在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。图 2-2(b) 说明了内核级线程的实现方式。

在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。图 2-2(c) 说明了用户级与内核级的组合实现方式。

* 如果主线程先于子线程结束会发生什么情况？[fn:2]

* 多线程是如何分配栈空间的？
  #+CAPTION: linux内存空间模型
  #+NAME:   fig:SED-HR4049
  [[http://image96.360doc.com/DownloadImg/2016/05/0611/71181556_1.jpg]]

  从上图可提取以下三点信息:
  + 进程栈空间从 0xC0000000 往下进行分配。
  + 运行时堆通过 malloc 进行分配, 位置处于. bss 与 0x40000000 之间
  + 在 Glibc 的 malloc 中, 对于小于 128k 的需求, 直接从堆中分配, 而大于 128k 的需求则通过 mmap 从文件映射区之后分配, 因此地址会大于 0x40000000.

  因此, 对于以 LinuxThread 实现的多线程而言, 要区分以下两种情况:
  + 管理线程, 管理线程的堆栈与普通进程无异, 即以上提到的三点（这里我认为，就是指主线程）
  + 普通线程, 因为线程会在进程堆中申请一块空间 (THREAD_MANAGER_STACK_SIZE=8M?)

  当作自已的运行栈, 而我们知道, 大于 128k 的 malloc 会采用 mmap 方式从文件映射区之后分配, 所以, 普通线程的栈地址就在这个空间内, 即大于 0x40000000


  #+BEGIN_HTML
<script src="https://gist.github.com/phenix3443/3e336faf2bbc5f06ff43e0e4abe3362c.js"></script>
   #+END_HTML

* 多线程同步和互斥异同？各自的实现方法有哪些？方法之间有何异同？各自的使用场景是什么？
  互斥解决的问题是竞争，同步解决的为难题是乱序。

  多线程同步实现方法：线程join、条件变量（condition）、屏障（barrier）、信号量（semaphore）。

  多线程互斥实现方法：互斥量、读写锁、自旋锁（pin lock）、信号量（semaphore）。

* 以下多线程对 int 型变量 x 的操作，哪几个不需要进行同步：
  #+BEGIN_EXAMPLE
  A. x=y;      B. x++;    C. ++x;    D. x=1;
  #+END_EXAMPLE

  答案是D，显然，y 的写入与 x 读 y 要同步，x++ 和 ++x 都要知道 x 之前的值，所以也要同步。
* 子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环 50 次，试写出代码。
  思路：使用两个条件变量。

* 编写一个程序，开启 3 个线程，这 3 个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出结果必须按 ABC 的顺序显示；如：ABCABC…. 依次递推。
  思路：用信号量进行各个子线程之间的互斥，创建 3 个信号量 A、B、C。初始时 A 的资源数为 1，B、C 的资源数为 0，访问 A 之后，将 B 的资源数加 1，访问 B 之后将 C 的资源数加 1，访问 C 之后将 A 的资源数加 1。创建 3 个子线程顺序访问资源 A、B、C。

* 有四个线程 1、2、3、4。线程 1 的功能就是输出 1，线程 2 的功能就是输出 2，以此类推......... 现在有四个文件 ABCD。初始都为空。现要让四个文件呈如下格式：
  #+BEGIN_EXAMPLE
  A：1 2 3 4 1 2....
  B：2 3 4 1 2 3....
  C：3 4 1 2 3 4....
  D：4 1 2 3 4 1....
  #+END_EXAMPLE
  请设计程序。

* 生产者消费者问题
  1. 生产者和消费这共享缓冲区。
  2. 不允许消费者到一个空的缓冲区中取产品
  3. 不允许生产者向一个已经装满产品且尚未被取走的缓冲区中投放产品。

* 读者写者问题
  有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者读时写者也不能写。

  分析：首先来找找哪些是属于 “等待” 情况。

  第一、写者要等到没有读者时才能去写文件。

  第二、所有读者要等待写者完成写文件后才能去读文件。

  找完 “等待” 情况后，再看看有没有要互斥访问的资源。由于只有一个写者而读者们是可以共享的读文件，所以按题目要求并没有需要互斥访问的资源。代码如下：


* 如何设计无锁队列？

* 多线程如何高效访问资源？

* 什么是线程安全？
  　如果多线程的程序运行结果是可预期的，而且与单线程的程序运行结果一样，那么说明是 “线程安全” 的。

* shared_ptr是线程安全的么？

* 编写线程安全的单例模式代码
  　在多线程编程中，有时候我们需要保证，无论程序创建了多少个线程，某些操作只执行了一次。Linux 提供了pthread_once()系统调用，我们可以借助pthread_once()实现单例模式：
  #+BEGIN_HTML
<script src="https://gist.github.com/phenix3443/624cc2d9bde80b4c03b152d6af52e473.js"></script>
  #+END_HTML

* 线程和进程的区别？
  + 进程是资源分配的基本单位，线程是 cpu 调度，或者说是程序执行的最小单位。在 Mac、Windows NT 等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。
  + 进程有独立的地址空间，比如在 linux 下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的。
  + 线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。
  + 由 b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。
  + 线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。

* 多进程和多线程软件架构的优缺点

* 常用的多线程设计范式
  读写锁范式

  生产消费范式

  blockingQueue

  concurrentHashmap

* Footnotes

[fn:1] https://www.kancloud.cn/hanghanghang/os/116942
[fn:2] [[http://liyuanlife.com/blog/2015/04/08/influence-of-main-threads-exiting-to-child-thread/][主线程退出对子线程的影响]]
