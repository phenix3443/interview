# -*- coding:utf-8-*-
#+TITLE: 线程面试问题
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 什么是线程？它出现的背景是什么？
  引入进程的目的，是为了使多道程序并发执行，以提高资源利用率和系统吞吐量；而引入线程，则是为了减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。

  线程最直接的理解就是 “轻量级进程”，它是一个基本的 CPU 执行单元，也是程序执行流的最小单元，由线程 ID、程序计数器、寄存器集合和堆栈组成。线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程，同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。

* 线程和进程的区别？
  + 进程是资源分配的基本单位，线程是 cpu 调度，或者说是程序执行的最小单位。在 Mac、Windows NT 等采用微内核结构的操作系统中，进程的功能发生了变化：它只是资源分配的单位，而不再是调度运行的单位。在微内核系统中，真正调度运行的基本单位是线程。因此，实现并发功能的单位是线程。
  + 进程有独立的地址空间，比如在 linux 下面启动一个新的进程，系统必须分配给它独立的地址空间，建立众多的数据表来维护它的代码段、堆栈段和数据段，这是一种非常昂贵的多任务工作方式。而运行一个进程中的线程，它们之间共享大部分数据，使用相同的地址空间，因此启动一个线程，切换一个线程远比进程操作要快，花费也要小得多。当然，线程是拥有自己的局部变量和堆栈（注意不是堆）的。
  + 线程之间的通信比较方便。统一进程下的线程共享数据（比如全局变量，静态变量），通过这些数据来通信不仅快捷而且方便，当然如何处理好这些访问的同步与互斥正是编写多线程程序的难点。而进程之间的通信只能通过进程通信的方式进行。
  + 由 b，可以轻易地得到结论：多进程比多线程程序要健壮。一个线程死掉整个进程就死掉了，但是在保护模式下，一个进程死掉对另一个进程没有直接影响。
  + 线程的执行与进程是有区别的。每个独立的线程有有自己的一个程序入口，顺序执行序列和程序的出口，但是线程不能独立执行，必须依附与程序之中，由应用程序提供多个线程的并发控制。

* 线程的基本状态及状态之间的关系？
  线程是程序执行流的最小单元。线程的基本状态包括：新线程态、可运行态、阻塞/非运行态、死亡态。

  各状态之间的关系如下：

  #+CAPTION: 线程状态
  #+NAME:   fig:SED-HR4049
  [[http://static.oschina.net/uploads/space/2013/1230/163922_UEm6_1426828.jpg]]

* 线程的实现方式[fn:1]
  线程的实现可以分为两类：用户级线程 (User-LevelThread, ULT) 和内核级线程 (Kemel-LevelThread, KLT)。内核级线程又称为内核支持的线程。

 在用户级线程中，有关线程管理的所有工作都由应用程序完成，内核意识不到线程的存在。应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程起始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。图 2-2(a) 说明了用户级线程的实现方式。

在内核级线程中，线程管理的所有工作由内核完成，应用程序没有进行线程管理的代码，只有一个到内核级线程的编程接口。内核为进程及其内部的每个线程维护上下文信息，调度也是在内核基于线程架构的基础上完成。图 2-2(b) 说明了内核级线程的实现方式。

在一些系统中，使用组合方式的多线程实现。线程创建完全在用户空间中完成，线程的调度和同步也在应用程序中进行。一个应用程序中的多个用户级线程被映射到一些（小于或等于用户级线程的数目）内核级线程上。图 2-2(c) 说明了用户级与内核级的组合实现方式。

* 多线程模型

* 多进程和多线程程序各自优缺点？

* 多线程有几种实现方法？

* 多线程是如何分配栈空间的？
  #+CAPTION: linux内存空间模型
  #+NAME:   fig:SED-HR4049
  [[http://image96.360doc.com/DownloadImg/2016/05/0611/71181556_1.jpg]]

  从上图可提取以下三点信息:
  + 进程栈空间从 0xC0000000 往下进行分配。
  + 运行时堆通过 malloc 进行分配, 位置处于. bss 与 0x40000000 之间
  + 在 Glibc 的 malloc 中, 对于小于 128k 的需求, 直接从堆中分配, 而大于 128k 的需求则通过 mmap 从文件映射区之后分配, 因此地址会大于 0x40000000.

  因此, 对于以 LinuxThread 实现的多线程而言, 要区分以下两种情况:
  + 管理线程, 管理线程的堆栈与普通进程无异, 即以上提到的三点（这里我认为，就是指主线程）
  + 普通线程, 因为线程会在进程堆中申请一块空间 (THREAD_MANAGER_STACK_SIZE=8M?)

  当作自已的运行栈, 而我们知道, 大于 128k 的 malloc 会采用 mmap 方式从文件映射区之后分配, 所以, 普通线程的栈地址就在这个空间内, 即大于 0x40000000


  #+BEGIN_HTML
<script src="https://gist.github.com/phenix3443/3e336faf2bbc5f06ff43e0e4abe3362c.js"></script>
   #+END_HTML
* 多线程同步和互斥异同？分别在什么情况下使用？
  所谓同步，表示有先有后，比较正式的解释是 “线程同步是指线程之间所具有的一种制约关系，一个线程的执行依赖另一个线程的消息，当它没有得到另一个线程的消息时应等待，直到消息到达时才被唤醒。” 所谓互斥，比较正式的说明是 “线程互斥是指对于共享的进程系统资源，在各单个线程访问时的排它性。当有若干个线程都要使用某一共享资源时，任何时刻最多只允许一个线程去使用，其它要使用该资源的线程必须等待，直到占用资源者释放该资源。线程互斥可以看成是一种特殊的线程同步。” 表示不能同时访问，也是个顺序问题，所以互斥是一种特殊的同步操作。

  举个例子，设有一个全局变量 global，为了保证线程安全，我们规定只有当主线程修改了 global 之后下一个子线程才能访问 global，这就需要同步主线程与子线程，可用关键段实现。当一个子线程访问 global 的时候另一个线程不能访问 global，那么就需要互斥。

* 多线程同步和互斥各自的实现方法？
  多线程同步有如下几种实现方法：事件、信号量

  多线程互斥有如下几种实现方法：临界区、事件、信号量、互斥量

  临界区（CS:critical section）、事件（Event）、互斥量（Mutex）、信号量（semaphores），需要注意的是，临界区是效率最高的，因为基本不需要其他的开销，二内核对象涉及到用户态和内核态的切换，开销较大，另外，关键段、互斥量具有线程所有权的概念，因此只可以用于线程之间互斥，而不能用到同步中。只有互斥量能完美解决进程意外终止所造成的 “遗弃问题”。

* 以下多线程对 int 型变量 x 的操作，哪几个不需要进行同步：
  #+BEGIN_EXAMPLE
  A. x=y;      B. x++;    C. ++x;    D. x=1;
  #+END_EXAMPLE

  答案是D，显然，y 的写入与 x 读 y 要同步，x++ 和 ++x 都要知道 x 之前的值，所以也要同步。
* 子线程循环 10 次，接着主线程循环 100 次，接着又回到子线程循环 10 次，接着再回到主线程又循环 100 次，如此循环 50 次，试写出代码。

* 有四个线程 1、2、3、4。线程 1 的功能就是输出 1，线程 2 的功能就是输出 2，以此类推......... 现在有四个文件 ABCD。初始都为空。现要让四个文件呈如下格式：
  #+BEGIN_EXAMPLE
  A：1 2 3 4 1 2....
  B：2 3 4 1 2 3....
  C：3 4 1 2 3 4....
  D：4 1 2 3 4 1....
  #+END_EXAMPLE
  请设计程序。

* 编写一个程序，开启 3 个线程，这 3 个线程的 ID 分别为 A、B、C，每个线程将自己的 ID 在屏幕上打印 10 遍，要求输出结果必须按 ABC 的顺序显示；如：ABCABC…. 依次递推。
  思路：用信号量进行各个子线程之间的互斥，创建 3 个信号量 A、B、C。初始时 A 的资源数为 1，B、C 的资源数为 0，访问 A 之后，将 B 的资源数加 1，访问 B 之后将 C 的资源数加 1，访问 C 之后将 A 的资源数加 1。创建 3 个子线程顺序访问资源 A、B、C。
* 生产者消费者问题
  有一个生产者在生产产品，这些产品将提供给若干个消费者去消费，为了使生产者和消费者能并发执行，在两者之间设置一个有多个缓冲区的缓冲池，生产者将它生产的产品放入一个缓冲区中，消费者可以从缓冲区中取走产品进行消费，所有生产者和消费者都是异步方式运行的，但它们必须保持同步，即不允许消费者到一个空的缓冲区中取产品，也不允许生产者向一个已经装满产品且尚未被取走的缓冲区中投放产品。

  思路：

  假设 1 个生产者，2 个消费者，缓冲区大小为 4。
  第一．从缓冲区取出产品和向缓冲区投放产品必须是互斥进行的。可以用关键段和互斥量来完成。
  第二．生产者要等待缓冲区为空，这样才可以投放产品，消费者要等待缓冲区不为空，这样才可以取出产品进行消费。并且由于有二个等待过程，所以要用二个事件或信号量来控制。
* 读者写者问题
  有一个写者很多读者，多个读者可以同时读文件，但写者在写文件时不允许有读者在读文件，同样有读者读时写者也不能写。

  分析：首先来找找哪些是属于 “等待” 情况。

  第一、写者要等到没有读者时才能去写文件。

  第二、所有读者要等待写者完成写文件后才能去读文件。

  找完 “等待” 情况后，再看看有没有要互斥访问的资源。由于只有一个写者而读者们是可以共享的读文件，所以按题目要求并没有需要互斥访问的资源。代码如下：


* 如何设计无锁队列？

* 多线程如何高效访问资源？

* 什么是线程安全？
  　如果多线程的程序运行结果是可预期的，而且与单线程的程序运行结果一样，那么说明是 “线程安全” 的。

* 一个全局变量 tally，两个线程并发执行（代码段都是 ThreadProc)，问两个线程都结束后，tally 取值范围。　
  #+BEGIN_SRC c++
      int tally = 0;//global
      voidThreadProc()
      {
              for(inti = 1; i <= 50; i++)
                      tally += 1;

      }
  #+END_SRC

  　当两线程串行时，结果最大为 100，当某个线程运行结束，而此时另外一个线程刚取出 0，还未计算时，结果最小为 50。

* Footnotes

[fn:1] https://www.kancloud.cn/hanghanghang/os/116942
