# -*- coding:utf-8-*-
#+TITLE: 进程面试题目
#+AUTHOR: liushangliang
#+EMAIL: phenix3443+github@gmail.com

* 什么是进程？它引入的背景是什么？[fn:1]
  在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。为此引入了进程 (Process) 的概念，以便更好地描述和控制程序的并发执行，实现操作系统的并发性和共享性。

  为了使参与并发执行的程序（含数据）能独立地运行，必须为之配置一个专门的数据结构，称为进程控制块 (Process Control Block, PCB)。系统利用 PCB 来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，由程序段、相关数据段和 PCB 三部分构成了进程映像（进程实体）。所谓创建进程，实质上是创建进程映像中的 PCB；而撤销进程，实质上是撤销进程的 PCB。值得注意的是，进程映像是静态的，进程则是动态的。

* 进程的状态和转换
  进程在其生命周期内，由于系统中各进程之间的相互制约关系及系统的运行环境的变化，使得进程的状态也在不断地发生变化（一个进程会经历若干种不同状态）。通常进程有以下五种状态，前三种是进程的基本状态。

  + 运行状态：进程正在处理机上运行。在单处理机环境下，每一时刻最多只有一个进程处于运行状态。
  + 就绪状态：进程已处于准备运行的状态，即进程获得了除处理机之外的一切所需资源，一旦得到处理机即可运行。
  + 阻塞状态，又称等待状态：进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入 / 输出完成。即使处理机空闲，该进程也不能运行。
  + 创建状态：进程正在被创建，尚未转到就绪状态。创建进程通常需要多个步骤：首先申请一个空白的 PCB，并向 PCB 中填写一些控制和管理进程的信息；然后由系统为该进程分配运行时所必需的资源；最后把该进程转入到就绪状态。
  + 结束状态：进程正从系统中消失，这可能是进程正常结束或其他原因中断退出运行。当进程需要结束运行时，系统首先必须置该进程为结束状态，然后再进一步处理资源释放和回收等工作。

  注意区别就绪状态和等待状态：就绪状态是指进程仅缺少处理机，只要获得处理机资源就立即执行；而等待状态是指进程需要其他资源（除了处理机）或等待某一事件。之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪状态的；而其他资源（如外设）的使用和分配或者某一事件的发生（如 I/O 操作的完成）对应的时间相对来说很长，进程转换到等待状态的次数也相对较少。这样来看，就绪状态和等待状态是进程生命周期中两个完全不同的状态，很显然需要加以区分。

  #+CAPTION: 进程状态以及转换
  #+NAME:   fig:SED-HR4049
  [[https://box.kancloud.cn/2016-02-16_56c29fbf29b50.png]]

  + 就绪状态 -> 运行状态：处于就绪状态的进程被调度后，获得处理机资源（分派处理机时间片），于是进程由就绪状态转换为运行状态。
  + 运行状态 -> 就绪状态：处于运行状态的进程在时间片用完后，不得不让出处理机，从而进程由运行状态转换为就绪状态。此外，在可剥夺的操作系统中，当有更高优先级的进程就 、 绪时，调度程度将正执行的进程转换为就绪状态，让更高优先级的进程执行。
  + 运行状态 -> 阻塞状态：当进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如 I/O 操作的完成）时，它就从运行状态转换为阻塞状态。进程以系统调用的形式请求操作系统提供服务，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。
  + 阻塞状态 -> 就绪状态：当进程等待的事件到来时，如 I/O 操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞状态转换为就绪状态。

* 进程控制
** 创建
   允许一个进程创建另一个进程。此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，也必须同时撤销其所有的子进程。
   在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。操作系统创建一个新进程的过程如下（创建原语)：
   1. 为新进程分配一个唯一的进程标识号，并申请一个空白的 PCB(PCB 是有限的)。若 PCB 申请失败则创建失败。
   2. 为进程分配资源，为新进程的程序和数据、以及用户栈分配必要的内存空间（在 PCB 中体现）。注意：这里如果资源不足（比如内存空间），并不是创建失败，而是处于” 等待状态 “，或称为 “阻塞状态”，等待的是内存这个资源。
   3. 初始化 PCB, 主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。
   4. 如果进程就绪队列能够接纳新进程，就将新进程插入到就绪队列，等待被调度运行。

** 终止
   引起进程终止的事件主要有：正常结束，表示进程的任务已经完成和准备退出运行。异常结束是指进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、I/O 故障等。外界干预是指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。

   操作系统终止进程的过程如下（撤销原语）：
   1. 根据被终止进程的标识符，检索 PCB，从中读出该进程的状态。
   2. 若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。
   3. 若该进程还有子进程，则应将其所有子进程终止。
   4. 将该进程所拥有的全部资源，或归还给其父进程或归还给操作系统。
   5. 将该 PCB 从所在队列（链表）中删除。
** 阻塞
   正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语 (Block)，使自己由运行状态变为阻塞状态。可见，进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得 CPU），才可能将其转为阻塞状态。

   阻塞原语的执行过程是：
   1. 找到将要被阻塞进程的标识号对应的 PCB。
   2. 若该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行。
   3. 把该 PCB 插入到相应事件的等待队列中去。
   4. 当被阻塞进程所期待的事件出现时，如它所启动的 I/O
** 唤醒
   操作已完成或其所期待的数据已到达，则由有关进程（比如，提供数据的进程）调用唤醒原语 (Wakeup)，将等待该事件的进程唤醒。

   唤醒原语的执行过程是：
   1. 在该事件的等待队列中找到相应进程的 PCB。
   2. 将其从等待队列中移出，并置其状态为就绪状态。
   3. 把该 PCB 插入就绪队列中，等待调度程序调度。

   需要注意的是，Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。 Block 原语是由被阻塞进程自我调用实现的，而 Wakeup 原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的。

** 切换
   进程切换的过程如下：
   1. 保存处理机上下文，包括程序计数器和其他寄存器。
   2. 更新 PCB 信息。
   3. 把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。
   4. 选择另一个进程执行，并更新其 PCB。
   5. 更新内存管理的数据结构。
   6. 恢复处理机上下文。

* 进程间通信

* 进程同步和互斥

* fork继承了哪些数据
  子进程继承了整个地址空间的副本，还从父进程继承了每个互斥量、读写锁和条件变量的状态。如果福进程包含一个以上的进程，子进程在fork返回以后，如果紧接着不是马上调用exec的话，就需要清理锁的状态。

  在子进程内部，只存在一个线程，它是由父进程中调用fork的线程的副本构成的。如果父进程中的线程占有锁，子进程同样占有这些锁。问题是子进程并不包含占有锁的线程的副本，所以子进程没有办法知道它占有了哪些锁，需要释放哪些锁。

  如果子进程从fork返回以后马上调用其中一个exec函数，就可以避免这样的问题。这种情况下，旧的地址空间就会被丢弃，所以锁的状态无关紧要。但如果子进程需要继续做处理工作的话，这种策略就行不通，还需要使用其他的策略。

* Footnotes

[fn:1] https://www.kancloud.cn/hanghanghang/os/116937
